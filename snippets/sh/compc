#!/usr/bin/bash

declare -A help

help[main]='
This snippet contains the scaffolding for Bash tab completion using
the complete -C foo foo variation which allows scripts to complete
themselves (rather than having another script somewhere to manage). To
use it simply add a function with the additional command and add the
name of it to the commands array declaration at the top of the script.
Then add complete -C foo foo (or something like it) to your bashrc.
Begin functions with x_ to allow useful command names to be used that
would otherwise conflict with existing system and bash keywords.
'

x_usage() {
    local cmds="${COMMANDS[@]}"
    printf "usage: %s (%s)\n" "${0##*/}" "${cmds// /|}"
}

x_help() { 
  local name=${1:-main} 
  local file="/tmp/$name-help.html"
  if [[ -n "$HELP_BROWSER" ]];then
    _make_html "$name"
    exec "$HELP_BROWSER" "$file"
  else
    pandoc -s -t plain  <<< "${help[${1:-main}]}" | more
  fi
}

x_foo() {
    echo would foo
}

x_foo_bar() {
    echo would foo bar
}

_make_html() {
  local name=${1:-main}
  local title="$EXE $name"
  [[ $name = main ]] && title="$EXE"
  pandoc -s --metadata title="$title" \
    -o "/tmp/$name-help.html" <<< "${help[$name]}"
}

# --------------------- completion and delegation --------------------

while read -r line; do
    [[ $line =~ ^declare\ -f\ x_ ]] || continue
    COMMANDS+=( ${line##declare -f x_} )
done < <(declare -F)

if [[ -n $COMP_LINE ]]; then
    line=${COMP_LINE#* }
    for c in "${COMMANDS[@]}"; do
        [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
    done
    exit
fi

declare cmd="$1"; shift
for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
        "x_$cmd" "$@"
        exit $?
    fi
done

x_usage "$@"
